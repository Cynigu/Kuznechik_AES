
# 1. Кузнечик ( ГОСТ 34.12—2015 )

Ссылка на гост : https://tc26.ru/standard/gost/GOST_R_3412-2015.pdf

Ссылка на норм обучение : https://xakep.ru/2017/02/02/working-with-grasshopper/

Про поле Галуа: https://konyakov.ru/pubs/books/kris-kaspersky-r_i_p/kris-kaspersky-07.pdf

Стандарт рекомендуется использовать при создании, эксплуатации и модернизации систем обработки информации различного назначения

Определения: 
- Блочный шифр - реализующий при каждом фиксированном значении ключа одно обратимое отображение множества блоков открытого текста фиксированной длины в блоки шифртекста такой же длины.
- Блок (block): Строка бит определенной длины.
- Итерационный ключ (round key): Последовательность символов, вычисляемая  в процессе развертывания ключа шифра, и определяющая преобразование на одной итерации блочного шифра.
- Ключ (key): Изменяемый параметр в виде последовательности символов, определяющий криптографическое преобразование.
- Развертывание ключа (key schedule): Вычисление итерационных ключей из ключа шифра.
- Симметричный криптографический метод (symmetric cryptographic technique): Криптографический метод, использующий один и тот же ключ для преобразования, осуществляемого отправителем, и  преобразования, осуществляемого получателем.
- SP — Substitution-Permutation network, или, по-русски, подстановочно-перестановочная сеть

# 2. Шифрование
Шифр получает на вход ключ (мастер-ключ) и текст для зашифровки и совершает несколько чередующихся раундов, состоящих из стадий подстановки и стадий перестановки.
В «Кузнечике» каждый раунд включает в себя линейное и нелинейное преобразование плюс операцию наложения так называемого итерационного ключа. Всего таких раундов девять и один последний неполный раунд, в котором выполняется только наложение последнего (десятого) итерационного ключа.

```
Подребнее об опреациях в пункте 5.
```

![image](https://user-images.githubusercontent.com/56064826/202936674-5c24c214-f8ea-4c52-9d1b-a4687001ac74.png)

## 2.1 Режимы шифрованиия текста с длиной большей чем длина блока

Чтобы зашифровать текст, длина которого больше длины блока, существует несколько режимов, описанных в стандарте — ГОСТ 34.13-2015:

- режим простой замены (Electronic Codebook, ECB);
- режим гаммирования (Counter, CTR);
- режим гаммирования с обратной связью по выходу (Output Feedback, OFB);
- режим простой замены с зацеплением (Cipher Block Chaining, CBC);
- режим гаммирования с обратной связью по шифротексту (Cipher Feedback, CFB);
- режим выработки имитовставки (Message Authentication Code, MAC).

Самый простой режим — это режим простой замены. В этом режиме текст разбивается на блоки, затем каждый блок зашифровывается отдельно от остальных, затем блоки зашифрованного текста склеиваются вместе и мы получаем шифрованное сообщение.

# 3. Дешифрованиие
```
Подребнее об опреациях в пункте 5.
```

![image](https://user-images.githubusercontent.com/56064826/203431877-5b5a0e3c-5d65-42d3-9691-659445366f7a.png)

# 4 Получение итерационных ключей 

В схеме указано ![image](https://user-images.githubusercontent.com/56064826/203437828-0815420e-e7ed-4d2e-a5f0-e03e174d98ff.png)

Итерационные (или раундовые) ключи получаются путем определенных преобразований на основе мастер-ключа. Процесс начинается с разбиения мастер-ключа пополам, так получается первая пара раундовых ключей.
Для генерации каждой последующей пары раундовых ключей применяется восемь итераций сети Фейстеля, в каждой итерации используется константа, которая вычисляется путем применения линейного преобразования алгоритма к значению номера итерации.

![image](https://user-images.githubusercontent.com/56064826/203427249-ac74eba7-6e43-4e87-8343-4b02acd78c8d.png)
```
Подребнее об опреациях в пункте 5. 
```

# 5. Операции, указанные в схемах шифрования/дешифрования/итерационных ключей
Все операции для шифрования/дешифрования происходятит в поле Галуа.

Арифметика полей Галуа — полиномиальная арифметика, то есть каждый элемент данного поля представляет собой некий полином. Результат любой операции также является элементом данного поля. Конкретное поле Галуа состоит из фиксированного диапазона чисел. В вычислительной технике наибольшее распространение получили поля Галуа с основанием 2, что объясняется естественностью этих полей с точки зрения машинной обработки, двоичной по своей природе.

GF(p^m) - обозначение поля Галуа, где p - характеристика поля (алфавит), m - максимальня длина слова.   

Если m = 1, то поле Галуа простое, если m > 1, то для образования поля необходим еще порождающий полином степени m, такое поле называется расширенным.

Порождающий полином является неприводимым, то есть простым (по аналогии с простыми числами делится без остатка на 1 и на самого себя). Так как работа с любой информацией — это работа с байтами, а байт представляет из себя 8 бит, в качестве поля Галуа берут GF(2^8) и порождающий полином:
![image](https://user-images.githubusercontent.com/56064826/203443255-bde42ef5-97a6-469b-9cc3-bd3c4fc8c452.png)


## 5.1 Сложение по модулю 2 (X-преобразование)
Используется во всех схемах.

Сложение по модулю два в полях Галуа тождественно вычитанию и реализуется битовой операцией XOR.

На схеме обозначено так:
![image](https://user-images.githubusercontent.com/56064826/203429080-5e6edae7-5a80-49fd-9899-da94b6dd1579.png)

Таблица истинности функции ХОR:

![image](https://user-images.githubusercontent.com/56064826/203440474-c923a57b-30d9-49e7-aded-364b52dc7ef0.png)

В полиномиальном виде данная операция будет выглядеть как:
![image](https://user-images.githubusercontent.com/56064826/203440620-23aa106c-a391-46d3-a932-7d63425be31d.png)

```c#
/// <summary>
/// Сложение двух двоичных векторов по модулю 2 (функция Х)
/// </summary>
/// <param name="a">первый вектор</param>
/// <param name="b">второй вектор</param>
/// <returns></returns>
private long GOST_Kuz_X( long a, long b)
{
    return a ^ b;
}
```

## 5.2 Операция умножения
Необходимо для преобразования L.


Пример умножения в G(2^3) (числа от 0 до 7):
1) Чтобы осуществить операцию умножения, необходимо преобразовать числа в полиномиальную форму:
![image](https://user-images.githubusercontent.com/56064826/203441809-6c260b7a-63e8-467f-9282-af9f4e15d4ce.png)

2) Перемножим два числа в полиномиальной форме:
![image](https://user-images.githubusercontent.com/56064826/203441928-2844fa5a-6eb5-4eb4-a465-b579855170f3.png)

3) Результат умножения 27 не входит в используемое поле. Чтобы бороться с этой проблемой, необходимо использовать порождающий полином (число 11). 


Для выполнения данного преобразования необходима функция умножения чисел в конечном поле (или поле Галуа) над неприводимым полиномом x^8 + x^7 + x^6 + x + 1.


## 5.2 Нелинейное биективное преобразование (преобразование S) 
Используется в схеме шифрования и получения ключей.

Обозначено так: ![image](https://user-images.githubusercontent.com/56064826/203439389-bc9266d8-ffe6-40b8-a57f-8e9e6d658398.png)


