
# 1. Кузнечик ( ГОСТ 34.12—2015 )

Ссылка на гост : https://tc26.ru/standard/gost/GOST_R_3412-2015.pdf

Ссылка на норм обучение : https://xakep.ru/2017/02/02/working-with-grasshopper/

Стандарт рекомендуется использовать при создании, эксплуатации и модернизации систем обработки информации различного назначения

Определения: 
- Блочный шифр - реализующий при каждом фиксированном значении ключа одно обратимое отображение множества блоков открытого текста фиксированной длины в блоки шифртекста такой же длины.
- Блок (block): Строка бит определенной длины.
- Итерационный ключ (round key): Последовательность символов, вычисляемая  в процессе развертывания ключа шифра, и определяющая преобразование на одной итерации блочного шифра.
- Ключ (key): Изменяемый параметр в виде последовательности символов, определяющий криптографическое преобразование.
- Развертывание ключа (key schedule): Вычисление итерационных ключей из ключа шифра.
- Симметричный криптографический метод (symmetric cryptographic technique): Криптографический метод, использующий один и тот же ключ для преобразования, осуществляемого отправителем, и  преобразования, осуществляемого получателем.
- SP — Substitution-Permutation network, или, по-русски, подстановочно-перестановочная сеть

# 2. Шифрование
Шифр получает на вход ключ (мастер-ключ) и текст для зашифровки и совершает несколько чередующихся раундов, состоящих из стадий подстановки и стадий перестановки.
В «Кузнечике» каждый раунд включает в себя линейное и нелинейное преобразование плюс операцию наложения так называемого итерационного ключа. Всего таких раундов девять и один последний неполный раунд, в котором выполняется только наложение последнего (десятого) итерационного ключа.

```
Подребнее об опреациях в пункте 5.
```

![image](https://user-images.githubusercontent.com/56064826/202936674-5c24c214-f8ea-4c52-9d1b-a4687001ac74.png)

## 2.1 Преобразование исходнго текста в пригодный для шифрования

Для шифрования с использованием алоритма Кузнечик нужен текст, который возмжно разбить на 16 байт (128 бит) и ключ, который равен 32 байтам (256 бит). Длина текста всегда должна быть кратна длине блока, поэтому текст всегда дополняется справа одним единичным битом и нулями до длины блока

```c#
private byte[][] TextFromStringToByte(string text)
{

    List<byte> temp = System.Text.Encoding.Default.GetBytes(text).ToList();
    int countByte = temp.Count;
    while (temp.Count % _blockSize != 0)
    {
        if (temp.Count == countByte) temp.Add(0x01);
        else temp.Add(0x00);
    }
    int countBlocks = temp.Count / _blockSize;
    byte[][] blocks = new byte[countBlocks][];

    for (int i = 0; i < countBlocks; i++)
    {
        blocks[i] = new byte[_blockSize];
        for (int j = i*_blockSize; j< (i+1)*_blockSize; j++)
        {
            blocks[i][j % _blockSize] = temp[j];
        }
    }
    return blocks;
}
```
## 2.2 Режимы шифрованиия текста с длиной большей чем длина блока

Чтобы зашифровать текст, длина которого больше длины блока, существует несколько режимов, описанных в стандарте — ГОСТ 34.13-2015:

- режим простой замены (Electronic Codebook, ECB);
- режим гаммирования (Counter, CTR);
- режим гаммирования с обратной связью по выходу (Output Feedback, OFB);
- режим простой замены с зацеплением (Cipher Block Chaining, CBC);
- режим гаммирования с обратной связью по шифротексту (Cipher Feedback, CFB);
- режим выработки имитовставки (Message Authentication Code, MAC).

Самый простой режим — это режим простой замены. В этом режиме текст разбивается на блоки, затем каждый блок зашифровывается отдельно от остальных, затем блоки зашифрованного текста склеиваются вместе и мы получаем шифрованное сообщение.

# 3. Дешифрованиие
```
Подребнее об опреациях в пункте 5.
```

![image](https://user-images.githubusercontent.com/56064826/203431877-5b5a0e3c-5d65-42d3-9691-659445366f7a.png)

# 4 Получение итерационных ключей 

В схеме указано ![image](https://user-images.githubusercontent.com/56064826/203437828-0815420e-e7ed-4d2e-a5f0-e03e174d98ff.png)

Итерационные (или раундовые) ключи получаются путем определенных преобразований на основе мастер-ключа. Процесс начинается с разбиения мастер-ключа пополам, так получается первая пара раундовых ключей.
Для генерации каждой последующей пары раундовых ключей применяется восемь итераций сети Фейстеля, в каждой итерации используется константа, которая вычисляется путем применения линейного преобразования алгоритма к значению номера итерации.

![image](https://user-images.githubusercontent.com/56064826/203427249-ac74eba7-6e43-4e87-8343-4b02acd78c8d.png)
```
Подребнее об опреациях в пункте 5. 
```

## 4.1 Преобразование исходного ключа в пригодный для шифрования/дешифрования

Разбиваем мастер-ключ на 2 ключа по 16 байт, если кол-во байт не кратно 16 в одном из ключей то дополняем 0x01 байтом и 0x00 байтами пока ключ не будет кратен 16

```c#

/// <summary>
/// Преобразование ключа из строки в байты
/// </summary>
/// <param name="bKey1">первый ключ из пары</param>
/// <param name="bKey2">второй ключ из пры</param>
/// <param name="masterKey">исходный ключ</param>
private void KeyFromStringToByte(out byte[] bKey1, out byte[] bKey2, string masterKey)
{
    bKey1 = new byte[_keySize];
    bKey2 = new byte[_keySize];

    List<byte> temp = System.Text.Encoding.Default.GetBytes(masterKey).ToList();

    if (temp.Count < _keySize*2)
    {
        var countByte = temp.Count; // чтобы добавить 0х01 во второй ключ, если размер ключа меньше 16 байт
        temp.Add(0x01);
        temp.AddRange(new byte[_keySize * 2 - temp.Count]); // дополняем нулями, если ключ меньше 32 байт

        if (countByte < _keySize)
        {
            temp[_keySize] = 0x01;
        }
    }

    for (int i = 0; i < _keySize; i++)
    {
        bKey1[i] = temp[i];
        bKey2[i] = temp[i + _keySize];
    }
}
```


#5. Операции, указанные в схемах шифрования/дешифрования/итерационных ключей

## 5.1 Сложение по модулю 2 (X-преобразование)
Используется во всех схемах.

На схеме обозначено так:
![image](https://user-images.githubusercontent.com/56064826/203429080-5e6edae7-5a80-49fd-9899-da94b6dd1579.png)

Каждый байт первого вектора ксорится с соответствующим байтом второго вектора, и результат пишется в третий (выходной) вектор. В коде записано так:

```c#

///<summary>
/// Сложение двух двоичных векторов по модулю 2 (функция Х)
/// </summary>
/// <param name="a">первый вектор</param>
/// <param name="b">второй вектор</param>
/// <returns></returns>
private byte[] GOST_Kuz_X( byte[] a, byte[] b)
{
    int i;
    byte[] c = new byte[_blockSize];
    for (i = 0; i < _blockSize; i++)
        c[i] = (byte)(a[i] ^ b[i]);
    return c;
}
```
## 5.2 Нелинейное биективное преобразование (преобразование S) 
Используется в схеме шифрования и получения ключей.

Обозначено так: ![image](https://user-images.githubusercontent.com/56064826/203439389-bc9266d8-ffe6-40b8-a57f-8e9e6d658398.png)




