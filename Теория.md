
# 1. Кузнечик ( ГОСТ 34.12—2015 )

Ссылка на гост : https://tc26.ru/standard/gost/GOST_R_3412-2015.pdf

Ссылка на норм обучение : https://xakep.ru/2017/02/02/working-with-grasshopper/

Стандарт рекомендуется использовать при создании, эксплуатации и модернизации систем обработки информации различного назначения

Определения: 
- Блочный шифр - реализующий при каждом фиксированном значении ключа одно обратимое отображение множества блоков открытого текста фиксированной длины в блоки шифртекста такой же длины.
- Блок (block): Строка бит определенной длины.
- Итерационный ключ (round key): Последовательность символов, вычисляемая  в процессе развертывания ключа шифра, и определяющая преобразование на одной итерации блочного шифра.
- Ключ (key): Изменяемый параметр в виде последовательности символов, определяющий криптографическое преобразование.
- Развертывание ключа (key schedule): Вычисление итерационных ключей из ключа шифра.
- Симметричный криптографический метод (symmetric cryptographic technique): Криптографический метод, использующий один и тот же ключ для преобразования, осуществляемого отправителем, и  преобразования, осуществляемого получателем.
- SP — Substitution-Permutation network, или, по-русски, подстановочно-перестановочная сеть

# 2. Шифрование
Шифр получает на вход ключ (мастер-ключ) и текст для зашифровки и совершает несколько чередующихся раундов, состоящих из стадий подстановки и стадий перестановки.
В «Кузнечике» каждый раунд включает в себя линейное и нелинейное преобразование плюс операцию наложения так называемого итерационного ключа. Всего таких раундов девять и один последний неполный раунд, в котором выполняется только наложение последнего (десятого) итерационного ключа.

![image](https://user-images.githubusercontent.com/56064826/202936674-5c24c214-f8ea-4c52-9d1b-a4687001ac74.png)

## 2.1 Преобразование исходных данных (ключ и текст) в удобоваримые для шифрования
Для шифрования с использованием алоритма Кузнечик нужен текст, который возмжно разбить на 16 байт (128 бит) и ключ, который равен 32 байтам (256 бит).

1) Подгоняем исходный текст под валидное значение (так чтобы можно было разбить на блоки по 16 байт): если количество байт текста не кратно 16 (количество блоков), то дополняем текст 0x01 байтом и 0x00 байтами пока кол-во байт не будет кратно 16

2) Разбиваем мастер-ключ на 2 ключа по 16 байт, если кол-во байт не кратно 16 в одном из ключей то дополняем 0x01 байтом и 0x00 байтами пока ключ не будет кратен 16

## 2.2 Получение итерационных ключей 

Итерационные (или раундовые) ключи получаются путем определенных преобразований на основе мастер-ключа. Процесс начинается с разбиения мастер-ключа пополам, так получается первая пара раундовых ключей.
Для генерации каждой последующей пары раундовых ключей применяется восемь итераций сети Фейстеля, в каждой итерации используется константа, которая вычисляется путем применения линейного преобразования алгоритма к значению номера итерации.

![image](https://user-images.githubusercontent.com/56064826/203427249-ac74eba7-6e43-4e87-8343-4b02acd78c8d.png)

## Сложение по модулю 2 (X-преобразование)
На схеме обозначено так:
![image](https://user-images.githubusercontent.com/56064826/203429080-5e6edae7-5a80-49fd-9899-da94b6dd1579.png)

Каждый байт первого вектора ксорится с соответствующим байтом второго вектора, и результат пишется в третий (выходной) вектор. В коде записано так:

```c#

///<summary>
/// Сложение двух двоичных векторов по модулю 2 (функция Х)
/// </summary>
/// <param name="a">первый вектор</param>
/// <param name="b">второй вектор</param>
/// <returns></returns>
private byte[] GOST_Kuz_X( byte[] a, byte[] b)
{
    int i;
    byte[] c = new byte[_blockSize];
    for (i = 0; i < _blockSize; i++)
        c[i] = (byte)(a[i] ^ b[i]);
    return c;
}
```
